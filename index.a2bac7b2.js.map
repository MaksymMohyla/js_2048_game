{"mappings":"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","sources":["<anon>","src/scripts/main.js"],"sourcesContent":["\"use strict\";\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nvar gameTable = document.querySelector(\".game-field\");\n/* змінна для перевірки кінця гри,\nякщо гра програна, керування в обробнику подій блокується */ var isGameOver = false;\nvar Game = /*#__PURE__*/ function() {\n    function Game(initialState) {\n        _class_call_check(this, Game);\n        this.initialState = [\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ],\n            [\n                0,\n                0,\n                0,\n                0\n            ]\n        ];\n        this.score = 0;\n    }\n    _create_class(Game, [\n        {\n            key: \"moveLeft\",\n            value: function moveLeft() {\n                /* перед кожним рухом робим копію попереднього стану, щоб\n    в методі compareStates() порівнювати їх і не додавати нову плитку\n    якщо рух в даному напрямку неможливий */ var previousState = JSON.parse(JSON.stringify(this.state));\n                for(var row = 0; row < 4; row++){\n                    var col = 0;\n                    // ітеруємо по всіх рядках зліва направо\n                    for(var i = 1; i < 4; i++){\n                        // якщо зустрічаєм непусту клітинку\n                        if (this.state[row][i] !== 0) for(var j = i; j > col; j--){\n                            // і якщо наступна пуста\n                            if (this.state[row][j - 1] === 0) {\n                                // переміщуєм її туди\n                                this.state[row][j - 1] = this.state[row][j];\n                                // попередня стає пуста\n                                this.state[row][j] = 0;\n                            // якщо натикаємось на таку саму\n                            } else if (this.state[row][j - 1] === this.state[row][j]) {\n                                // наступна клітинка стає х2, а попередня пустою\n                                this.state[row][j - 1] *= 2;\n                                this.state[row][j] = 0;\n                                // оновлення очок на значення злитої клітинки.\n                                this.score += this.state[row][j - 1];\n                                // використовується для відстеження останньої непустої клітинки\n                                col = j;\n                                break;\n                            } else {\n                                col = j - 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                this.updateHTML();\n                if (!this.compareStates(previousState, this.state)) this.addRandomTile();\n                this.updateScore();\n                // перевірка на перемогу чи поразку в кінці кожного ходу\n                switch(this.getStatus()){\n                    case \"lose\":\n                        this.gameOver();\n                        break;\n                    case \"win\":\n                        document.querySelector(\".message-win\").classList.remove(\"hidden\");\n                        break;\n                }\n            }\n        },\n        {\n            key: \"moveRight\",\n            value: function moveRight() {\n                var previousState = JSON.parse(JSON.stringify(this.state));\n                for(var row = 0; row < 4; row++){\n                    var col = 3;\n                    // тепер ітерація справа наліво\n                    for(var i = 2; i >= 0; i--){\n                        if (this.state[row][i] !== 0) for(var j = i; j < col; j++){\n                            if (this.state[row][j + 1] === 0) {\n                                this.state[row][j + 1] = this.state[row][j];\n                                this.state[row][j] = 0;\n                            } else if (this.state[row][j + 1] === this.state[row][j]) {\n                                this.state[row][j + 1] *= 2;\n                                this.state[row][j] = 0;\n                                this.score += this.state[row][j + 1];\n                                col = j;\n                                break;\n                            } else {\n                                col = j + 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                this.updateHTML();\n                if (!this.compareStates(previousState, this.state)) this.addRandomTile();\n                this.updateScore();\n                switch(this.getStatus()){\n                    case \"lose\":\n                        this.gameOver();\n                        break;\n                    case \"win\":\n                        document.querySelector(\".message-win\").classList.remove(\"hidden\");\n                        break;\n                }\n            }\n        },\n        {\n            key: \"moveUp\",\n            value: function moveUp() {\n                var previousState = JSON.parse(JSON.stringify(this.state));\n                for(var col = 0; col < 4; col++){\n                    var row = 0;\n                    // ітерація по колонках\n                    for(var i = 1; i < 4; i++){\n                        if (this.state[i][col] !== 0) for(var j = i; j > row; j--){\n                            if (this.state[j - 1][col] === 0) {\n                                this.state[j - 1][col] = this.state[j][col];\n                                this.state[j][col] = 0;\n                            } else if (this.state[j - 1][col] === this.state[j][col]) {\n                                this.state[j - 1][col] *= 2;\n                                this.state[j][col] = 0;\n                                this.score += this.state[j - 1][col];\n                                row = j;\n                                break;\n                            } else {\n                                row = j - 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                this.updateHTML();\n                if (!this.compareStates(previousState, this.state)) this.addRandomTile();\n                this.updateScore();\n                switch(this.getStatus()){\n                    case \"lose\":\n                        this.gameOver();\n                        break;\n                    case \"win\":\n                        document.querySelector(\".message-win\").classList.remove(\"hidden\");\n                        break;\n                }\n            }\n        },\n        {\n            key: \"moveDown\",\n            value: function moveDown() {\n                var previousState = JSON.parse(JSON.stringify(this.state));\n                for(var col = 0; col < 4; col++){\n                    var row = 3;\n                    for(var i = 2; i >= 0; i--){\n                        if (this.state[i][col] !== 0) for(var j = i; j < row; j++){\n                            if (this.state[j + 1][col] === 0) {\n                                this.state[j + 1][col] = this.state[j][col];\n                                this.state[j][col] = 0;\n                            } else if (this.state[j + 1][col] === this.state[j][col]) {\n                                this.state[j + 1][col] *= 2;\n                                this.state[j][col] = 0;\n                                this.score += this.state[j + 1][col];\n                                row = j;\n                                break;\n                            } else {\n                                row = j + 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                this.updateHTML();\n                if (!this.compareStates(previousState, this.state)) this.addRandomTile();\n                this.updateScore();\n                switch(this.getStatus()){\n                    case \"lose\":\n                        this.gameOver();\n                        break;\n                    case \"win\":\n                        document.querySelector(\".message-win\").classList.remove(\"hidden\");\n                        break;\n                }\n            }\n        },\n        {\n            key: \"compareStates\",\n            value: function compareStates(state1, state2) {\n                for(var row = 0; row < 4; row++)for(var col = 0; col < 4; col++){\n                    if (state1[row][col] !== state2[row][col]) return false;\n                }\n                return true;\n            }\n        },\n        {\n            key: \"getStatus\",\n            value: function getStatus() {\n                // метод для перевірки можливості ходів нижче\n                var isAnyMovePossible = this.isAnyMovePossible();\n                // перевірка чи масив містить 2048\n                var hasWon = this.state.some(function(row) {\n                    return row.includes(2048);\n                });\n                if (hasWon) return \"win\";\n                else if (!isAnyMovePossible) return \"lose\";\n                else return \"playing\";\n            }\n        },\n        {\n            key: \"isAnyMovePossible\",\n            value: function isAnyMovePossible() {\n                /* якщо є хоча б одне порожнє місце або є\n     сусідні плитки з однаковими числами, то є можливий хід */ for(var row = 0; row < 4; row++)for(var col = 0; col < 4; col++){\n                    if (this.state[row][col] === 0 || col < 3 && this.state[row][col] === this.state[row][col + 1] || row < 3 && this.state[row][col] === this.state[row + 1][col]) return true;\n                }\n                return false;\n            }\n        },\n        {\n            key: \"gameOver\",\n            value: function gameOver() {\n                document.querySelector(\".message-lose\").classList.remove(\"hidden\");\n                isGameOver = true;\n            }\n        },\n        {\n            key: \"start\",\n            value: function start() {\n                // створюєм копію початкового масиву, щоб працювати з нею в подальшому\n                this.state = JSON.parse(JSON.stringify(this.initialState));\n                this.updateHTML();\n                /* метод addRandomTile додає рандомну клітинку в пустому місці поля,\n    тому викликаєм його двічі для кнопки старт */ for(var i = 0; i < 2; i++)this.addRandomTile();\n            }\n        },\n        {\n            key: \"addRandomTile\",\n            value: function addRandomTile() {\n                var row, col;\n                do {\n                    /* для колонок і рядків створюєм рандомне число між 0 і 3\n      (бо індекси в js поч з 0) і присвоюєм числа в масив стану */ row = Math.floor(Math.random() * 4);\n                    col = Math.floor(Math.random() * 4);\n                }while (this.state[row][col] !== 0);\n                // 10% шансом може з'явитись 4:\n                this.state[row][col] = Math.random() < 0.1 ? 4 : 2;\n                // вибираєм клітинку в самому HTML\n                var cell = gameTable.rows[row].cells[col];\n                /* присвоюєм вміст клітинки згідно масиву, додаєм клас\n    (напр field-cell--2 щоб клітинки відрізнялись по кольору)\n    для кольору і для анімації появи */ cell.textContent = this.state[row][col];\n                cell.classList.add(\"field-cell--\".concat(this.state[row][col]));\n                cell.classList.add(\"slide-in-down\");\n                setTimeout(function() {\n                    cell.classList.remove(\"slide-in-down\");\n                }, 300); // час, відповідний тривалості переходу в CSS\n            }\n        },\n        {\n            key: \"updateHTML\",\n            value: function updateHTML() {\n                /* метод для оновлення стану поля згідно числам в масиві state.\n    ітеруєм по всіх рядках і колонках поля */ for(var row = 0; row < 4; row++)for(var col = 0; col < 4; col++){\n                    var cell = gameTable.rows[row].cells[col];\n                    // якщо число в масиві 0, то і вміст клітинки буде пустий\n                    cell.textContent = this.state[row][col] || \"\";\n                    /* якщо число в масиві яке відповідає за дану клітинку 0,\n        то скидаєм клас до стандартного, щоб був колір пустої плитки,\n        якщо клітинка не пуста, до додаєм клас до неї (сам клас css -\n        таке ж число як в масиві, тому ними зручно маніпулювати) */ cell.className = \"field-cell\";\n                    if (this.state[row][col]) cell.classList.add(\"field-cell--\".concat(this.state[row][col]));\n                }\n            }\n        },\n        {\n            key: \"updateScore\",\n            value: function updateScore() {\n                // оновлення очок відбувається при рухові поля, значення береться із об'єкта\n                var scores = document.querySelector(\".game-score\");\n                scores.textContent = this.score;\n            }\n        }\n    ]);\n    return Game;\n}();\nvar game = new Game();\nvar startBtn = document.querySelector(\".start\");\nstartBtn.addEventListener(\"click\", function() {\n    /* при нажиманні на кнопку старт, викликаєм відповідний метод\n  з класу і перетворюєм кнопку на рестарт, скидаєм щотчик очок */ game.start();\n    startBtn.classList.remove(\"start\");\n    startBtn.classList.add(\"restart\");\n    startBtn.innerText = \"Restart\";\n    game.score = 0;\n    game.updateScore();\n    // перезапуск гри якщо гравець програв\n    if (isGameOver) {\n        document.querySelector(\".message-lose\").classList.add(\"hidden\");\n        isGameOver = false;\n    }\n});\ndocument.addEventListener(\"keydown\", function(e) {\n    /* додаємо керування стрілками на клавіатурі.\n   запобігаєм стандартній поведінці клавіш */ if (!isGameOver) {\n        e.preventDefault();\n        switch(e.key){\n            case \"ArrowLeft\":\n                game.moveLeft();\n                break;\n            case \"ArrowRight\":\n                game.moveRight();\n                break;\n            case \"ArrowUp\":\n                game.moveUp();\n                break;\n            case \"ArrowDown\":\n                game.moveDown();\n                break;\n        }\n    }\n});\n// додавання сенсорного керування\nvar startX, startY;\ndocument.addEventListener(\"touchstart\", function(e) {\n    // зберігаємо координати початку дотику\n    startX = e.touches[0].clientX;\n    startY = e.touches[0].clientY;\n});\ndocument.addEventListener(\"touchend\", function(e) {\n    // oбчислюємо різницю координат для визначення напрямку свайпу\n    var endX = e.changedTouches[0].clientX;\n    var endY = e.changedTouches[0].clientY;\n    var deltaX = endX - startX;\n    var deltaY = endY - startY;\n    // визначаємо напрямок свайпу\n    if (Math.abs(deltaX) > Math.abs(deltaY)) {\n        // горизонтальний свайп\n        if (deltaX > 0) game.moveRight();\n        else game.moveLeft();\n    } else // вертикальний свайп\n    if (deltaY > 0) game.moveDown();\n    else game.moveUp();\n});\n\n//# sourceMappingURL=index.a2bac7b2.js.map\n","'use strict';\n\nconst gameTable = document.querySelector('.game-field');\n\n/* змінна для перевірки кінця гри,\nякщо гра програна, керування в обробнику подій блокується */\nlet isGameOver = false;\n\nclass Game {\n  constructor(initialState) {\n    this.initialState = [\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n      [0, 0, 0, 0],\n    ];\n    this.score = 0;\n  }\n\n  moveLeft() {\n    /* перед кожним рухом робим копію попереднього стану, щоб\n    в методі compareStates() порівнювати їх і не додавати нову плитку\n    якщо рух в даному напрямку неможливий */\n    const previousState = JSON.parse(JSON.stringify(this.state));\n\n    for (let row = 0; row < 4; row++) {\n      let col = 0;\n\n      // ітеруємо по всіх рядках зліва направо\n      for (let i = 1; i < 4; i++) {\n        // якщо зустрічаєм непусту клітинку\n        if (this.state[row][i] !== 0) {\n          for (let j = i; j > col; j--) {\n            // і якщо наступна пуста\n            if (this.state[row][j - 1] === 0) {\n              // переміщуєм її туди\n              this.state[row][j - 1] = this.state[row][j];\n              // попередня стає пуста\n              this.state[row][j] = 0;\n              // якщо натикаємось на таку саму\n            } else if (this.state[row][j - 1] === this.state[row][j]) {\n              // наступна клітинка стає х2, а попередня пустою\n              this.state[row][j - 1] *= 2;\n              this.state[row][j] = 0;\n              // оновлення очок на значення злитої клітинки.\n              this.score += this.state[row][j - 1];\n              // використовується для відстеження останньої непустої клітинки\n              col = j;\n              break;\n            } else {\n              col = j - 1;\n              break;\n            }\n          }\n        }\n      }\n    }\n    this.updateHTML();\n\n    if (!this.compareStates(previousState, this.state)) {\n      this.addRandomTile();\n    }\n    this.updateScore();\n\n    // перевірка на перемогу чи поразку в кінці кожного ходу\n    switch (this.getStatus()) {\n      case 'lose':\n        this.gameOver();\n        break;\n      case 'win':\n        document.querySelector('.message-win').classList.remove('hidden');\n        break;\n    }\n  }\n\n  moveRight() {\n    const previousState = JSON.parse(JSON.stringify(this.state));\n\n    for (let row = 0; row < 4; row++) {\n      let col = 3;\n\n      // тепер ітерація справа наліво\n      for (let i = 2; i >= 0; i--) {\n        if (this.state[row][i] !== 0) {\n          for (let j = i; j < col; j++) {\n            if (this.state[row][j + 1] === 0) {\n              this.state[row][j + 1] = this.state[row][j];\n              this.state[row][j] = 0;\n            } else if (this.state[row][j + 1] === this.state[row][j]) {\n              this.state[row][j + 1] *= 2;\n              this.state[row][j] = 0;\n              this.score += this.state[row][j + 1];\n              col = j;\n              break;\n            } else {\n              col = j + 1;\n              break;\n            }\n          }\n        }\n      }\n    }\n    this.updateHTML();\n\n    if (!this.compareStates(previousState, this.state)) {\n      this.addRandomTile();\n    }\n    this.updateScore();\n\n    switch (this.getStatus()) {\n      case 'lose':\n        this.gameOver();\n        break;\n      case 'win':\n        document.querySelector('.message-win').classList.remove('hidden');\n        break;\n    }\n  }\n\n  moveUp() {\n    const previousState = JSON.parse(JSON.stringify(this.state));\n\n    for (let col = 0; col < 4; col++) {\n      let row = 0;\n\n      // ітерація по колонках\n      for (let i = 1; i < 4; i++) {\n        if (this.state[i][col] !== 0) {\n          for (let j = i; j > row; j--) {\n            if (this.state[j - 1][col] === 0) {\n              this.state[j - 1][col] = this.state[j][col];\n              this.state[j][col] = 0;\n            } else if (this.state[j - 1][col] === this.state[j][col]) {\n              this.state[j - 1][col] *= 2;\n              this.state[j][col] = 0;\n              this.score += this.state[j - 1][col];\n              row = j;\n              break;\n            } else {\n              row = j - 1;\n              break;\n            }\n          }\n        }\n      }\n    }\n    this.updateHTML();\n\n    if (!this.compareStates(previousState, this.state)) {\n      this.addRandomTile();\n    }\n    this.updateScore();\n\n    switch (this.getStatus()) {\n      case 'lose':\n        this.gameOver();\n        break;\n      case 'win':\n        document.querySelector('.message-win').classList.remove('hidden');\n        break;\n    }\n  }\n\n  moveDown() {\n    const previousState = JSON.parse(JSON.stringify(this.state));\n\n    for (let col = 0; col < 4; col++) {\n      let row = 3;\n\n      for (let i = 2; i >= 0; i--) {\n        if (this.state[i][col] !== 0) {\n          for (let j = i; j < row; j++) {\n            if (this.state[j + 1][col] === 0) {\n              this.state[j + 1][col] = this.state[j][col];\n              this.state[j][col] = 0;\n            } else if (this.state[j + 1][col] === this.state[j][col]) {\n              this.state[j + 1][col] *= 2;\n              this.state[j][col] = 0;\n              this.score += this.state[j + 1][col];\n              row = j;\n              break;\n            } else {\n              row = j + 1;\n              break;\n            }\n          }\n        }\n      }\n    }\n    this.updateHTML();\n\n    if (!this.compareStates(previousState, this.state)) {\n      this.addRandomTile();\n    }\n    this.updateScore();\n\n    switch (this.getStatus()) {\n      case 'lose':\n        this.gameOver();\n        break;\n      case 'win':\n        document.querySelector('.message-win').classList.remove('hidden');\n        break;\n    }\n  }\n\n  compareStates(state1, state2) {\n    for (let row = 0; row < 4; row++) {\n      for (let col = 0; col < 4; col++) {\n        if (state1[row][col] !== state2[row][col]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  getStatus() {\n    // метод для перевірки можливості ходів нижче\n    const isAnyMovePossible = this.isAnyMovePossible();\n\n    // перевірка чи масив містить 2048\n    const hasWon = this.state.some((row) => row.includes(2048));\n\n    if (hasWon) {\n      return 'win';\n    } else if (!isAnyMovePossible) {\n      return 'lose';\n    } else {\n      return 'playing';\n    }\n  }\n\n  isAnyMovePossible() {\n    /* якщо є хоча б одне порожнє місце або є\n     сусідні плитки з однаковими числами, то є можливий хід */\n    for (let row = 0; row < 4; row++) {\n      for (let col = 0; col < 4; col++) {\n        if (\n          this.state[row][col] === 0 ||\n          (col < 3 && this.state[row][col] === this.state[row][col + 1]) ||\n          (row < 3 && this.state[row][col] === this.state[row + 1][col])\n        ) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  gameOver() {\n    document.querySelector('.message-lose').classList.remove('hidden');\n    isGameOver = true;\n  }\n\n  start() {\n    // створюєм копію початкового масиву, щоб працювати з нею в подальшому\n    this.state = JSON.parse(JSON.stringify(this.initialState));\n    this.updateHTML();\n\n    /* метод addRandomTile додає рандомну клітинку в пустому місці поля,\n    тому викликаєм його двічі для кнопки старт */\n    for (let i = 0; i < 2; i++) {\n      this.addRandomTile();\n    }\n  }\n\n  addRandomTile() {\n    let row, col;\n\n    do {\n      /* для колонок і рядків створюєм рандомне число між 0 і 3\n      (бо індекси в js поч з 0) і присвоюєм числа в масив стану */\n      row = Math.floor(Math.random() * 4);\n      col = Math.floor(Math.random() * 4);\n    } while (this.state[row][col] !== 0);\n\n    // 10% шансом може з'явитись 4:\n    this.state[row][col] = Math.random() < 0.1 ? 4 : 2;\n\n    // вибираєм клітинку в самому HTML\n    const cell = gameTable.rows[row].cells[col];\n\n    /* присвоюєм вміст клітинки згідно масиву, додаєм клас\n    (напр field-cell--2 щоб клітинки відрізнялись по кольору)\n    для кольору і для анімації появи */\n    cell.textContent = this.state[row][col];\n    cell.classList.add(`field-cell--${this.state[row][col]}`);\n    cell.classList.add('slide-in-down');\n\n    setTimeout(() => {\n      cell.classList.remove('slide-in-down');\n    }, 300); // час, відповідний тривалості переходу в CSS\n  }\n\n  updateHTML() {\n    /* метод для оновлення стану поля згідно числам в масиві state.\n    ітеруєм по всіх рядках і колонках поля */\n    for (let row = 0; row < 4; row++) {\n      for (let col = 0; col < 4; col++) {\n        const cell = gameTable.rows[row].cells[col];\n\n        // якщо число в масиві 0, то і вміст клітинки буде пустий\n        cell.textContent = this.state[row][col] || '';\n\n        /* якщо число в масиві яке відповідає за дану клітинку 0,\n        то скидаєм клас до стандартного, щоб був колір пустої плитки,\n        якщо клітинка не пуста, до додаєм клас до неї (сам клас css -\n        таке ж число як в масиві, тому ними зручно маніпулювати) */\n        cell.className = 'field-cell';\n\n        if (this.state[row][col]) {\n          cell.classList.add(`field-cell--${this.state[row][col]}`);\n        }\n      }\n    }\n  }\n\n  updateScore() {\n    // оновлення очок відбувається при рухові поля, значення береться із об'єкта\n    const scores = document.querySelector('.game-score');\n\n    scores.textContent = this.score;\n  }\n}\n\nconst game = new Game();\n\nconst startBtn = document.querySelector('.start');\n\nstartBtn.addEventListener('click', () => {\n  /* при нажиманні на кнопку старт, викликаєм відповідний метод\n  з класу і перетворюєм кнопку на рестарт, скидаєм щотчик очок */\n  game.start();\n  startBtn.classList.remove('start');\n  startBtn.classList.add('restart');\n  startBtn.innerText = 'Restart';\n  game.score = 0;\n  game.updateScore();\n\n  // перезапуск гри якщо гравець програв\n  if (isGameOver) {\n    document.querySelector('.message-lose').classList.add('hidden');\n    isGameOver = false;\n  }\n});\n\ndocument.addEventListener('keydown', (e) => {\n  /* додаємо керування стрілками на клавіатурі.\n   запобігаєм стандартній поведінці клавіш */\n  if (!isGameOver) {\n    e.preventDefault();\n\n    switch (e.key) {\n      case 'ArrowLeft':\n        game.moveLeft();\n        break;\n      case 'ArrowRight':\n        game.moveRight();\n        break;\n      case 'ArrowUp':\n        game.moveUp();\n        break;\n      case 'ArrowDown':\n        game.moveDown();\n        break;\n    }\n  }\n});\n\n// додавання сенсорного керування\nlet startX, startY;\n\ndocument.addEventListener('touchstart', (e) => {\n  // зберігаємо координати початку дотику\n  startX = e.touches[0].clientX;\n  startY = e.touches[0].clientY;\n});\n\ndocument.addEventListener('touchend', (e) => {\n  // oбчислюємо різницю координат для визначення напрямку свайпу\n  const endX = e.changedTouches[0].clientX;\n  const endY = e.changedTouches[0].clientY;\n  const deltaX = endX - startX;\n  const deltaY = endY - startY;\n\n  // визначаємо напрямок свайпу\n  if (Math.abs(deltaX) > Math.abs(deltaY)) {\n    // горизонтальний свайп\n    if (deltaX > 0) {\n      game.moveRight();\n    } else {\n      game.moveLeft();\n    }\n  } else {\n    // вертикальний свайп\n    if (deltaY > 0) {\n      game.moveDown();\n    } else {\n      game.moveUp();\n    }\n  }\n});\n"],"names":["startX","startY","gameTable","document","querySelector","isGameOver","game","protoProps","Game","initialState","_class_call_check","instance","Constructor","TypeError","score","key","value","previousState","JSON","parse","stringify","state","row","col","i","j","updateHTML","compareStates","addRandomTile","updateScore","getStatus","gameOver","classList","remove","state1","state2","isAnyMovePossible","some","includes","Math","floor","random","cell","rows","cells","textContent","add","concat","setTimeout","className","scores","_defineProperties","target","props","length","descriptor","enumerable","configurable","writable","Object","defineProperty","prototype","startBtn","addEventListener","start","innerText","e","preventDefault","moveLeft","moveRight","moveUp","moveDown","touches","clientX","clientY","endX","changedTouches","endY","deltaX","deltaY","abs"],"version":3,"file":"index.a2bac7b2.js.map"}